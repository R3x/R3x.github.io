<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Siddharth&#39;s Blog</title>
    <link>https://R3x.github.io/</link>
    <description>Recent content on Siddharth&#39;s Blog</description>
    <image>
      <url>https://R3x.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://R3x.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 31 Oct 2022 23:43:10 +0000</lastBuildDate><atom:link href="https://R3x.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LLVM Tips/Tricks</title>
      <link>https://R3x.github.io/posts/llvm_ir_tips/</link>
      <pubDate>Mon, 31 Oct 2022 23:43:10 +0000</pubDate>
      
      <guid>https://R3x.github.io/posts/llvm_ir_tips/</guid>
      <description>LLVM Tips/Tricks This is a collection of tips/tricks that I have learned while working with LLVM. I will keep updating this page as I learn more.
(Last updated: 31st October 2022)
Debugging LLVM (opt) passes with VSCode Refer to this blog post: Debugging LLVM (opt) passes with VSCode to ease the process of debugging LLVM passes using VSCode&amp;rsquo;s amazing debugging capabilities.
Generating the CFG for a function Using IDA Pro for reverse engineering binaries, has made me a huge fan of CFGs, for analyzing control flows for low level applications.</description>
    </item>
    
    <item>
      <title>Advanced GDB Debugging</title>
      <link>https://R3x.github.io/posts/gdb_advanced/</link>
      <pubDate>Tue, 25 Oct 2022 23:43:10 +0000</pubDate>
      
      <guid>https://R3x.github.io/posts/gdb_advanced/</guid>
      <description>Advanced GDB Debugging In this post, I would like to point out some tips/tricks to make debugging easier with GDB. I will be focusing on Linux x86_64 binaries, but most of the things should work on other architectures as well. I will try to cover both
I am gonna assume basic familiarity with GDB, such as setting breakpoints/stepping through code, etc. If you are not familiar with GDB, I would recommend reading/watching some basic tutorial for GDB.</description>
    </item>
    
    <item>
      <title>Debugging LLVM (opt) passes with VSCode</title>
      <link>https://R3x.github.io/posts/llvm_debug/</link>
      <pubDate>Sun, 04 Sep 2022 23:43:10 +0000</pubDate>
      
      <guid>https://R3x.github.io/posts/llvm_debug/</guid>
      <description>Debugging LLVM (opt) passes with VSCode In this blog, I plan to look at how to debug LLVM passes (specifically opt passes) with VSCode. I have been working with opt passes in VSCode for a while, and realized that people have a really hard time debugging them. I have had labmates switch to CLion for writting LLVM passes. So, here&amp;rsquo;s a guide on setting up VSCode for debugging llvm-opt passes.</description>
    </item>
    
    <item>
      <title>Digging into ELFs (Part 1)</title>
      <link>https://R3x.github.io/posts/elf_1/</link>
      <pubDate>Tue, 26 Jul 2022 23:43:10 +0000</pubDate>
      
      <guid>https://R3x.github.io/posts/elf_1/</guid>
      <description>Digging into ELFs (Part 1) In this blog, I plan to look at the ELF file format, specifically the ELF headers, sections and segments. This is gonna be a part of a series that I hope to complete part-by-part this month.
I am planning to use the LIEF python module to help me look at ELFs and understand what&amp;rsquo;s happening.
Overview ELF file contains a header and data. The data is divided into segments, each segment can contian a number of sections.</description>
    </item>
    
    <item>
      <title>Digging into ELFs (Part 2)</title>
      <link>https://R3x.github.io/posts/elf_2/</link>
      <pubDate>Tue, 26 Jul 2022 23:43:10 +0000</pubDate>
      
      <guid>https://R3x.github.io/posts/elf_2/</guid>
      <description>Digging into ELFs (Part 2) Last time, I spent time looking at the ELF headers. And we got a decent idea of how the ELF file format stores data in various segments and sections. Now let&amp;rsquo;s look deeper into different sections that are present in the ELF file.
What are those various sections? To view the sections using the LIEF python module, we can use the following script:
import lief binary = lief.</description>
    </item>
    
    <item>
      <title>New Website/Blog</title>
      <link>https://R3x.github.io/posts/temp/</link>
      <pubDate>Sun, 20 Feb 2022 23:43:10 +0000</pubDate>
      
      <guid>https://R3x.github.io/posts/temp/</guid>
      <description>Hello World! Yay! I finally decided to switch from wordpress to creating my own website. I was getting a lot of paywalls and it was becoming pretty painful to update the website every now and then.
Let&amp;rsquo;s see how it goes.</description>
    </item>
    
    
    <item>
      <title>Exec System Call</title>
      <link>https://R3x.github.io/posts/linux_system_calls/exec/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://R3x.github.io/posts/linux_system_calls/exec/</guid>
      <description>Exec System Call Welcome to the first installment in a blog series that will takes a deep dive into the mechanics of system calls. Today, we&amp;rsquo;re kicking things off with the exec system calls, a fundamental feature in Unix and Linux operating systems.
Glibc version used : 2.37 Bootlin
Introduction to the exec library calls Note: Please skip this section if you are already familiar with exec library calls.
In Unix and Linux systems, the exec family of library calls plays an essential role in process creation and management.</description>
    </item>
    
    
  </channel>
</rss>
